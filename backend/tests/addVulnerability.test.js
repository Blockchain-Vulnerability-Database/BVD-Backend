const request = require('supertest');
const app = require('../server'); // Import your Express app
const fs = require('fs');
const path = require('path');

jest.mock('fs'); // Mock the filesystem module

describe('POST /addVulnerability', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should add a vulnerability successfully', async () => {
    const mockFilePath = '/mock/path/to/metadata.json';
    const mockFileContent = JSON.stringify({
      id: 'BVC-TEST-001',
      title: 'Sample Vulnerability',
    });

    // Mock file existence and content
    fs.existsSync.mockReturnValue(true);
    fs.readFileSync.mockReturnValue(mockFileContent);

    const payload = {
      id: 'BVC-TEST-001',
      title: 'Test Vulnerability',
      description: 'Test description',
      metadata: mockFilePath,
    };

    const response = await request(app).post('/addVulnerability').send(payload);

    expect(response.statusCode).toBe(201);
    expect(response.body).toHaveProperty('message', 'Vulnerability added successfully.');
    expect(response.body).toHaveProperty('receipt');
  });

  it('should fail if metadata file does not exist', async () => {
    fs.existsSync.mockReturnValue(false); // Mock file does not exist

    const payload = {
      id: 'BVC-TEST-002',
      title: 'Test Vulnerability',
      description: 'Test description',
      metadata: '/nonexistent/path.json',
    };

    const response = await request(app).post('/addVulnerability').send(payload);

    expect(response.statusCode).toBe(400);
    expect(response.body).toHaveProperty('errors');
    expect(response.body.errors[0].msg).toBe('metadata file path is invalid or does not exist');
  });
});