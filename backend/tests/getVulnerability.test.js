const request = require('supertest');
const app = require('../server'); // Import your Express app
const { ethers } = require('ethers');

jest.mock('ethers'); // Mock ethers.js

describe('GET /getVulnerability/:id', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should retrieve a vulnerability successfully', async () => {
    const mockVulnerability = {
      id: ethers.encodeBytes32String('BVC-TEST-001'),
      title: 'Sample Vulnerability',
      description: 'This is a sample vulnerability',
      ipfsCid: 'bafybeid2x3n4example',
      isActive: true,
    };

    jest.spyOn(global.contract, 'getVulnerability').mockResolvedValue(mockVulnerability);

    const response = await request(app).get('/getVulnerability/BVC-TEST-001');

    expect(response.statusCode).toBe(200);
    expect(response.body).toHaveProperty('status', 'success');
    expect(response.body.vulnerability).toMatchObject({
      id: 'BVC-TEST-001',
      title: 'Sample Vulnerability',
      description: 'This is a sample vulnerability',
      ipfsCid: 'bafybeid2x3n4example',
      isActive: true,
    });
  });

  it('should return 404 if vulnerability does not exist', async () => {
    jest.spyOn(global.contract, 'getVulnerability').mockResolvedValue({ id: ethers.ZeroHash });

    const response = await request(app).get('/getVulnerability/BVC-NONEXISTENT');

    expect(response.statusCode).toBe(404);
    expect(response.body).toHaveProperty('error', 'Vulnerability does not exist');
  });
});